#!/bin/sh
# modules-load - load kernel modules from configuration files
# See COPYING for license terms and COPYRIGHT for notices.

######################################################################
# Section: Error codes                                               #
######################################################################

readonly E_GENERAL=1      # General error
#readonly E_CMDEXEC=126   # Command invoked cannot execute
readonly E_INTERRUPT=130  # Interrupted by signal

######################################################################
# Section: Exit hooks                                                #
######################################################################

# shellcheck disable=2317
interrupted() {
	echo "" 1>&2
	echo "modules-load: interrupted" 1>&2
	exit $E_INTERRUPT
}

# shellcheck disable=2317
atexit() {
	:
}

######################################################################
# Section: Modules-load routines                                     #
######################################################################

# has_content - Check if file has non-comment lines.
has_content() {
	file=$1
	while IFS= read -r line; do
		case "$line" in
		''|'#'*) continue ;;
		      *) return 0 ;;
		esac
	done < "$file"
	return 1
}

# load_file - Load modules listed in a configuration file.
# Args:
#   $1: Path to configuration file.
load_file() {
	file=$1
	while IFS= read -r line; do
		case "$line" in
		''|'#'*)
			continue
			;;
		*)
			# Reject arguments or options
			case "$line" in
			*' '* | *'	'*)
				printf "modules-load: invalid entry: %s\n" \
					"$line"
				FAILED="$FAILED $line"
				continue
				;;
			esac

			if [ "$VERBOSE" -eq 1 ]; then
				printf "modules-load: loading %s\n" \
					"$line"
			else
				printf "%s\n" "$line"
			fi

			if [ "$DRY_RUN" -eq 0 ]; then
				if ! "$MODPROBE" "$line"; then
					FAILED="$FAILED $line"
				fi
			fi
			;;
	esac
	done < "$file"
}

# modules_load - Process configuration directories in precedence order.
modules_load() {
	seen=""
	for dir in /etc/modules-load.d /run/modules-load.d \
		/lib/modules-load.d;
	do
		[ -d "$dir" ] || continue

		for file in "$dir"/*.conf; do
			[ -e "$file" ] || continue

			base="${file##*/}"
			case " $seen " in *" $base "*) continue ;; esac
			seen="$seen $base"

			if has_content "$file"; then
				load_file "$file"
			fi
			# Empty or comment-only file disables
			# lower-priority config
		done
	done
}

######################################################################
# Section: Command-line helpers                                      #
######################################################################

# Print usage information on stderr and exit with error.
usage() {
	printf "usage: modules-load [-nv]\n" 1>&2
	exit $E_GENERAL
}

# parse_options - Parse command-line options using POSIX `getopts` and
# set the corresponding global variables.
# Args:
#   $@: Command-line arguments.
parse_options() {
	while getopts ":nv" opt; do
		case "$opt" in
		n) DRY_RUN=1 ;;
		v) VERBOSE=1 ;;
		\?) usage ;;
		esac
	done
	shift $((OPTIND - 1))
}

# main - The main entry point of the script.
# Args:
#   $@: Command-line arguments.
main() {
	# Parse command-line options.
	parse_options "$@"

	# Root check.
	if [ "$DRY_RUN" -eq 0 ] && ! test -w /; then
		printf "modules-load: must be run as root\n" 1>&2
		exit $E_GENERAL
	fi

	# Load modules.
	modules_load

	if [ -n "$FAILED" ]; then
		printf "modules-load: failed modules: %s\n" "$FAILED" 1>&2
		exit $E_GENERAL
	fi
}

######################################################################
# Section: Script initialization                                     #
######################################################################

# Set trap handlers for interrupt signals and script exit.
trap "interrupted" HUP INT QUIT TERM # Handle interrupt signals.
trap "atexit" EXIT                   # Call atexit on script exit.

# Force a predictable, portable locale for glob sorting.
export LC_ALL=POSIX

# Global variables.
DRY_RUN=0
VERBOSE=0
FAILED=""

# Resolve modprobe path.
MODPROBE=/sbin/modprobe
[ -x "$MODPROBE" ] || MODPROBE=modprobe

######################################################################
# Section: Script execution                                          #
######################################################################

main "$@"

# vim: ft=sh cc=72 tw=70
# End of file.
